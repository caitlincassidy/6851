<head>

<link rel="stylesheet" href="greedy-geometric-bst.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

<script type="text/javascript">
  // TODO: Write a better sleep function that can be used
  // to animate the drawing of points
  var sleep = function(sleepDuration) {
    var now = new Date().getTime();
    while(new Date().getTime() < now + sleepDuration) {
    /* do nothing */
    } 
  }

  // Represent each point as a json object:
  // {'time': time, 'value': value, 'isOriginalPoint': boolean}
  // where 'time' = time accessed and 'value' = the value of the key and 'isOriginalPoint' is true if the point
  // was in the original set of search points.

  var currentPoints = [];

  // Returns true if the rectangle with firstPoint and secondPoint
  // is unsatisfied and false otherwise.
  // currentPoints is the set of points we currently have.
  var unsatisfiedRectangle = function(firstPoint, secondPoint, currentPoints) {
  		if (firstPoint == secondPoint) {
  			return false;
  		}
  		// If they don't actually form a rectangle (they form a line),
  		// this is by definition already satisfied
  		if (firstPoint.value == secondPoint.value ||
  			firstPoint.time == secondPoint.time) {
  			return false;
  		}

  		var lowerTimeBound = Math.min(firstPoint.time, secondPoint.time);
  		var upperTimeBound = Math.max(firstPoint.time, secondPoint.time);
  		var lowerValueBound = Math.min(firstPoint.value, secondPoint.value);
  		var upperValueBound = Math.max(firstPoint.value, secondPoint.value);

  		var isUnsatisfied = true;
  		currentPoints.forEach(function(point) {
  			if (point == firstPoint || point == secondPoint) {
  				// Shouldn't take into account itself

  			} else if (lowerTimeBound <= point.time &&
  				point.time <= upperTimeBound &&
  				lowerValueBound <= point.value &&
  				point.value <= upperValueBound) {
  				// There's a point within the rectangle, so it's not unsatisfied
  				isUnsatisfied = false;
  			}
  		});

  		return isUnsatisfied;
  	}


  // Stores how long the next item should wait
  // before showing up
  var currentTotalTimeout = 0;

  // Draw a point during the normal animation --
  // use this if you're drawing a point for the first time.
  var drawPointAnimated = function(canvas, currentSearchPoint) {
    currentTotalTimeout += 1000;
    setTimeout(function() {
      drawPoint(canvas, currentSearchPoint);
    }, currentTotalTimeout);
  }

  // Draw a point immediately on the canvas.
  // Use this *only* to redraw points that have been
  // previously drawn.
  var drawPoint = function(canvas, currentSearchPoint) {    
    var xCoordinate = currentSearchPoint.time;
    var yCoordinate = canvas.height - currentSearchPoint.value;

    var pointRadius = 5;

    var ctx = canvas.getContext('2d');
    if (currentSearchPoint.isOriginalPoint) {
      ctx.fillStyle = 'blue';
    } else {
      ctx.fillStyle = 'red';
    }

    ctx.beginPath();
    ctx.arc(xCoordinate, yCoordinate, pointRadius, 0, 2*Math.PI, false);
    ctx.fill();
    ctx.closePath();
  }

  var drawUnsatisfiedRectangle = function(canvas, firstPoint, secondPoint) {
    currentTotalTimeout += 1000;

    // Ensure firstPoint is the top left corner of the rectangle
    if (secondPoint.value > firstPoint.value &&
        secondPoint.time < firstPoint.time) {
      var temp = firstPoint;
      firstPoint = secondPoint;
      secondPoint = temp;
    }

    var xCoordinate = firstPoint.time;
    var yCoordinate = canvas.height - firstPoint.value;
    var width = secondPoint.time - firstPoint.time;
    var height = firstPoint.value - secondPoint.value;

    setTimeout(function() {
      ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'green';
      ctx.fillStyle = 'green';
      ctx.strokeWidth = 1;
      ctx.strokeRect(xCoordinate, yCoordinate, width, height);
    },
    currentTotalTimeout);

    // Delete the rectangle at the same time as you add
    // the point the satisfies the rectangle
    setTimeout(function() {
      // TODO: Figure out what's the correct rectangle to clear
      // clear where the rectangle was
      ctx.clearRect(xCoordinate-1, yCoordinate-1, width+4, height+4);
      // Redraw its corners
      drawPoint(canvas, firstPoint);
      drawPoint(canvas, secondPoint);
    },
    currentTotalTimeout + 1000);
  }

  // Prints the points that satisfy the greedy geometric BST algorithm.
  // ctx is the canvas on which to draw the points
  // searchPoints must be in order from smallest to largest value
  var greedyGeometricBst = function(canvas, searchPoints) {

  	if (searchPoints.length == 0) {
  		// Base case: we're done searching
  		var finalList = currentPoints.slice();
  		console.log("final list:");
  		console.log(finalList);
  		// Reset current points so greedyGeometricBst can be called again.
  		currentPoints = [];
  		return;
  	}

  	var currentSearchPoint = searchPoints[0];

  	// Add search point to our list
  	currentPoints.push(currentSearchPoint);

    // Draw this point on the canvas
    drawPointAnimated(canvas, currentSearchPoint, true);

  	// See if there's any unsatisfied rectangles
  	// If there are, satisfy them
  	currentPoints.forEach(function(point) {
  		if (unsatisfiedRectangle(point, currentSearchPoint, currentPoints)) {
          drawUnsatisfiedRectangle(canvas, point, currentSearchPoint);
  				// If unsatisfied, must add a point
  				// the point should be on the same row as the current
  				// search point, so it should have the same time as
  				// the other point
  		 		var newPointValue = currentSearchPoint.value;
  		 		var newPointTime = point.time;
  		 		var newPoint = {
  		 			'time': newPointTime,
  		 			'value': newPointValue,
            'isOriginalPoint': false,
  		 		}
  		 		currentPoints.push(newPoint);
          drawPointAnimated(canvas, newPoint, false);
  		}
  	});

  	// Recurse with the next search point
  	greedyGeometricBst(canvas, searchPoints.slice(1));

  };

  // Call function as an example
  /*greedyGeometricBst([{'time': 3, 'value': 10},
  					  {'time': 1, 'value': 20},
  					  {'time': 4, 'value': 30},
  					  {'time': 2, 'value': 40}]);

  greedyGeometricBst([{'time': 5, 'value': 100},
  					  {'time': 5, 'value': 200}]);*/


  $(document).ready(function() {
    var canvas = document.getElementById('graph-canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = "300";
    canvas.height = "300";
    //$('#graph-div').height(300);
    //$('#graph-div').width(300);

    console.log("starting greedy geometric bst");
    var exampleArray =
             [{'time': 30, 'value': 10, 'isOriginalPoint': true},
              {'time': 10, 'value': 20, 'isOriginalPoint': true},
              {'time': 40, 'value': 30, 'isOriginalPoint': true},
              {'time': 20, 'value': 40, 'isOriginalPoint': true}];

    greedyGeometricBst(canvas, exampleArray);

  })


</script>

</head>

<body>

<p> 6.851 CO4 Coding: Implement geometric view of BSTs </p>

<p> Caitlin Cassidy </p>

<p> Use the console to try it out! The example from class: </p>

<p>   greedyGeometricBst([{'time': 3, 'value': 10},
  					  {'time': 1, 'value': 20},
  					  {'time': 4, 'value': 30},
  					  {'time': 2, 'value': 40}]); </p>

<canvas id="graph-canvas"></canvas>

<!--<div id="graph-div"></div>-->

</body>
